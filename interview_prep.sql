-- Database for a store

CREATE TABLE orders (
	order_id INT PRIMARY KEY, 
	customer_id INT
	order_date TIMESTAMP
	order_amount INT
	department_id INT
);

CREATE TABLE departments ( 
	department_id INT PRIMARY KEY, 
	department_name VARCHAR(50)
) ;

CREATE TABLE customers (
	customer_id INT PRIMARY KEY,
	last_name VARCHAR(255), 
	first_name VARCHAR (255)
);

-- Questions 

-- 1. Retrieve the total revenue generated by each department over the past 12 months, 
-- presenting the results sorted in descending order of revenue. 
SELECT 
	d.department_name, 
	SUM(o.order_amount) AS revenue
FROM orders AS o
INNER JOIN departments AS d
	ON o.department_id = d.department_id
WHERE order_date >= (DATE_TRUNC('day', CURRENT_TIMESTAMP) - INTERVAL '12 months')  
GROUP BY d.department_name
ORDER BY revenue DESC; 

-- 2. Determine the distinct number of users who placed orders specifically from the 'Electronics' department 
-- and the 'Fashion' department, respectively, for the year 2022.
SELECT d.department_name, COUNT(DISTINCT o.customer_id)
FROM orders AS o
INNER JOIN departments AS d
	ON o.department_id = d.department_id
WHERE d.department_name IN ('Electronics', 'Fashion')
	AND EXTRACT(YEAR FROM order_date) = 2022
GROUP BY d.department_name; 

-- 3. Write a SQL query to identify the customer with the highest number of orders 
-- for each calendar year within the past 5 years (including partial years), relative to today's date. 
-- The query should return one top customer per year, based on the total number of orders they placed in that year.
WITH ranked_customer_orders AS
(
    SELECT
        EXTRACT(YEAR FROM o.order_date) AS years,
        c.customer_id,
        c.first_name,
        c.last_name,
        COUNT(o.order_id) AS orders,
        RANK() OVER(PARTITION BY EXTRACT(YEAR FROM o.order_date) ORDER BY COUNT(o.order_id) DESC) AS ranking
    FROM customers AS c
    INNER JOIN orders AS o
        ON c.customer_id = o.customer_id
    WHERE o.order_date >= (DATE_TRUNC('day', CURRENT_TIMESTAMP) - INTERVAL '5 years')
    GROUP BY
        EXTRACT(YEAR FROM o.order_date),
        c.customer_id,
        c.first_name,
        c.last_name
)
SELECT * 
FROM ranked_customer_orders	
WHERE ranking = 1;

-- Update the above query logic to exclude the current year and include only
-- the customers with the most orders in each of the last 5 full calendar years.


-- 4. Identify the second highest individual order amount recorded within the 'Fashion' department. 
WITH ranked_order_amounts AS 
(
	SELECT 
		department_name, 
		order_amount,
		DENSE_RANK() OVER(ORDER BY order_amount DESC) AS ranking 
		-- so it doesn't skip rank numbers when there is a tie
	FROM orders AS o
	INNER JOIN departments AS d
		ON o.department_id = d.department_id
	WHERE d.department_name = 'Fashion'
)
SELECT order_amount AS second_highest_order_amount
FROM ranked_order_amount
WHERE ranking = 2;

-- 5. Find the department with the highest month-over-month increase in order amount from November 2022 to December 2022.

-- If you only want to consider the month-over-month increase 
-- for departments that had recorded sales in both November and December. 
WITH nov AS
(
	SELECT 
		department_name,
		SUM(order_amount) AS nov_revenue
	FROM orders AS o
	INNER JOIN departments AS d
		ON o.department_id = d.department_id
	WHERE EXTRACT(YEAR FROM order_date) = 2022 AND EXTRACT(MONTH FROM order_date) = 11 
-- EXTRACT(MONTH FROM order_date) - This would return an integer representing the month of the specified date
	GROUP BY department_name																				
),

dec AS 
(
	SELECT 
		department_name,
		SUM(order_amount) AS dec_revenue
	FROM orders AS o
	INNER JOIN departments AS d
		ON o.department_id = d.department_id
	WHERE EXTRACT(YEAR FROM order_date) = 2022 AND EXTRACT(MONTH FROM order_date) = 12
	GROUP BY department_name
) 

SELECT 
	d.department_name, 
	(d.dec_revenue - n.nov_revenue) AS difference 
FROM nov AS n
INNER JOIN dec AS d
	ON n.department_name = d.department_name
ORDER BY difference DESC
LIMIT 1;

-- If you also want to account for departments that had sales in one month but not the other 
-- (e.g., started selling in December, or stopped selling in December), treating their missing month's revenue as zero.
WITH nov AS
(
	SELECT 
		department_name,
		SUM(order_amount) AS nov_revenue
	FROM orders AS o
	INNER JOIN departments AS d
		ON o.department_id = d.department_id
	WHERE EXTRACT(YEAR FROM order_date) = 2022 AND EXTRACT(MONTH FROM order_date) = 11 
	GROUP BY department_name																				
),

dec AS 
(
	SELECT 
		department_name,
		SUM(order_amount) AS dec_revenue
	FROM orders AS o
	INNER JOIN departments AS d
		ON o.department_id = d.department_id
	WHERE EXTRACT(YEAR FROM order_date) = 2022 AND EXTRACT(MONTH FROM order_date) = 12
	GROUP BY department_name
) 
-- This is where it changes 
SELECT
    COALESCE(n.department_name, d.department_name) AS department_name, -- Get department name from either side
    (COALESCE(d.dec_revenue, 0) - COALESCE(n.nov_revenue, 0)) AS difference
FROM nov AS n
FULL OUTER JOIN dec AS d
    ON n.department_name = d.department_name
ORDER BY difference DESC
LIMIT 1;

-- Here, COALESCE(n.department_name, d.department_name) ensures you get the department name 
-- even if it only appeared in one of the CTEs (either nov or dec). 
-- COALESCE(d.dec_revenue, 0) and COALESCE(n.nov_revenue, 0) treat any missing monthly revenue as 0, 
-- allowing for correct increase/decrease calculations.


-- Note:
-- In SQL, the LIMIT and OFFSET clauses (or their equivalents like FETCH FIRST/NEXT and TOP) are executed very late in the query processing order, specifically after the ORDER BY clause.
-- Here's the typical logical order of execution for a SQL query:
-- FROM and JOIN clauses: Determines the set of base rows by specifying the tables involved and how they are related.
-- ON clause: Filters rows as they are joined.
-- WHERE clause: Filters rows from the combined (joined) result set based on specified conditions.
-- GROUP BY clause: Groups the rows that survived the WHERE clause based on specified columns.
-- HAVING clause: Filters the groups created by GROUP BY.
-- SELECT clause: Selects the columns to be returned, performs calculations, and assigns aliases. This is also where window functions are typically evaluated.
-- DISTINCT (if present): Eliminates duplicate rows from the results of the SELECT clause.
-- ORDER BY clause: Sorts the final set of rows according to the specified columns and order (ASC/DESC). This is crucial for LIMIT and OFFSET to work as intended.
-- LIMIT / OFFSET (or TOP/FETCH FIRST):
-- OFFSET is applied first: It skips a specified number of rows from the beginning of the sorted result set.
-- LIMIT (or FETCH FIRST) is applied second: It restricts the number of remaining rows to be returned after the offset has been applied.
-- This order of execution is fundamental to how SQL databases retrieve and present data.